{
  "name": "Phase 11: Blog Planning & Writing",
  "description": "Add blog post creation tied to keyword clusters. BlogCampaign (1:1 with cluster) + BlogPost models, topic discovery service (4-stage: POP seeds → Claude expand → DataForSEO enrich → Claude filter), blog content generation pipeline (reuse existing brief→write→check pattern with blog template), blog internal linking (blogs link UP to cluster pages + sideways to sibling blogs, siloed), HTML/clipboard export (NOT Matrixify), and full frontend UI (campaign cards on project detail, create campaign, keyword approval, content generation progress, 3-field Lexical editor, link planning, link map, HTML export page).",
  "branchName": "v2-rebuild",
  "userStories": [
    {
      "id": "S11-001",
      "title": "Create BlogCampaign and BlogPost SQLAlchemy models",
      "description": "As a developer, I need BlogCampaign and BlogPost models so that blog data can be stored with a 1:1 relationship to keyword clusters.",
      "acceptanceCriteria": [
        "Create backend/app/models/blog.py with BlogCampaign class extending Base",
        "BlogCampaign fields: id (UUID PK), project_id (FK projects, CASCADE), cluster_id (FK keyword_clusters, UNIQUE — 1:1), name (String 255), status (String 50, default 'planning', values: planning/writing/review/complete), generation_metadata (JSONB nullable), created_at (DateTime TZ), updated_at (DateTime TZ)",
        "Create BlogPost class extending Base in same file",
        "BlogPost fields: id (UUID PK), campaign_id (FK blog_campaigns, CASCADE), primary_keyword (Text), url_slug (String 255), search_volume (Integer nullable), source_page_id (FK cluster_pages nullable — which POP report seeded this topic), title (Text nullable — page_title), meta_description (Text nullable), content (Text nullable — single HTML field, NOT top/bottom split), pop_brief (JSONB nullable), is_approved (Boolean default false — keyword approved), content_status (String 50 default 'pending', values: pending/generating/complete/failed), content_approved (Boolean default false), qa_results (JSONB nullable), status (String 50 default 'keyword_pending', values: keyword_pending/generating/editing/complete), created_at (DateTime TZ), updated_at (DateTime TZ)",
        "Add relationships: BlogCampaign.posts (one-to-many), BlogCampaign.cluster, BlogCampaign.project, BlogPost.campaign with back_populates",
        "Register both models in backend/app/models/__init__.py",
        "Follow UUID/timestamp/relationship patterns from backend/app/models/keyword_cluster.py"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Key design decision: BlogPost stores content directly (title, meta_description, content) instead of bridging to CrawledPage/PageContent. Blogs have 3 content fields not 4, and don't need crawl-related fields. Follow the KeywordCluster + ClusterPage parent/child pattern from backend/app/models/keyword_cluster.py.",
      "completionNotes": "Completed by agent"
    },
    {
      "id": "S11-002",
      "title": "Create Alembic migration for blog tables",
      "description": "As a developer, I need database tables for blog_campaigns and blog_posts so that blog data can be persisted.",
      "acceptanceCriteria": [
        "Create migration file backend/alembic/versions/0026_create_blog_tables.py",
        "Migration creates blog_campaigns table with UNIQUE constraint on cluster_id (enforces 1:1)",
        "Migration creates blog_posts table with all fields from BlogPost model",
        "Add appropriate indexes: blog_campaigns(project_id), blog_campaigns(cluster_id), blog_posts(campaign_id), blog_posts(source_page_id)",
        "Migration runs successfully: cd backend && alembic upgrade head",
        "Migration has proper downgrade function that drops both tables"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Follow pattern from backend/alembic/versions/ existing migrations. The cluster_id UNIQUE constraint is critical — it prevents multiple campaigns per cluster.",
      "completionNotes": "Completed by agent"
    },
    {
      "id": "S11-003",
      "title": "Create Pydantic v2 schemas for blog endpoints",
      "description": "As a developer, I need request/response schemas for all blog API endpoints.",
      "acceptanceCriteria": [
        "Create backend/app/schemas/blog.py with Pydantic v2 models",
        "BlogCampaignCreate: cluster_id (UUID required), name (str optional)",
        "BlogPostResponse: id, campaign_id, primary_keyword, url_slug, search_volume, source_page_id, title, meta_description, content (truncated for list views), is_approved, content_status, content_approved, qa_results, status, created_at, updated_at — with ConfigDict(from_attributes=True)",
        "BlogCampaignResponse: id, project_id, cluster_id, name, status, generation_metadata, posts (list[BlogPostResponse]), created_at, updated_at — with ConfigDict(from_attributes=True)",
        "BlogCampaignListItem: id, name, status, cluster_name (str), post_count (int), approved_count (int), content_complete_count (int), created_at",
        "BlogPostUpdate: primary_keyword (str optional), url_slug (str optional), is_approved (bool optional)",
        "BlogContentUpdateRequest: title (str optional), meta_description (str optional), content (str optional)",
        "BlogContentGenerationStatus: overall_status, posts_total, posts_completed, posts_failed, posts (list of per-post status items)",
        "BlogExportItem: post_id, primary_keyword, url_slug, title, meta_description, html_content, word_count"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Follow pattern from backend/app/schemas/cluster.py. Use Pydantic v2 style: BaseModel, ConfigDict(from_attributes=True), Field(...) for validation. The BlogPostResponse should NOT include full content in list views — truncate or omit.",
      "completionNotes": "Completed by agent"
    },
    {
      "id": "S11-004",
      "title": "Create blog topic discovery service",
      "description": "As a developer, I need a service that discovers blog topics from existing POP reports using a 4-stage pipeline.",
      "acceptanceCriteria": [
        "Create backend/app/services/blog_topic_discovery.py with BlogTopicDiscoveryService class",
        "Constructor takes ClaudeClient and DataForSEOClient (same pattern as ClusterKeywordService)",
        "Stage 1 — extract_pop_seeds(cluster_id, db): query approved ClusterPages with POP briefs, extract related_searches and related_questions from each brief's JSONB, deduplicate, return seeds with source_page_id",
        "Stage 2 — expand_topics(seeds, brand_context): Claude Haiku expands seeds into 15-25 blog topic candidates, focuses on informational intent (how-to, guide, comparison, listicle), tags each with source_page_id",
        "Stage 3 — enrich_with_volume(candidates): DataForSEO batch volume lookup, filter zero-volume topics, merge volume/CPC/competition data (reuse exact pattern from ClusterKeywordService._enrich_with_volume)",
        "Stage 4 — filter_and_rank(candidates, cluster_name): Claude Haiku filters to best 8-15 topics, removes near-duplicates, generates URL slugs, assigns relevance scores",
        "Orchestrator discover_topics(cluster_id, project_id, brand_config, db, name): runs stages 1-4, creates BlogCampaign with status='planning', creates BlogPost records with status='keyword_pending', returns result dict with campaign_id and suggestion count",
        "Error handling: if DataForSEO fails, continue without volume data; if Claude fails, return error to user"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Follow the 4-stage pattern from backend/app/services/cluster_keyword.py (ClusterKeywordService). The key difference is Stage 1: instead of taking a seed keyword from the user, we extract seeds from existing POP content briefs stored on cluster pages. POP briefs are stored as JSONB on the ContentBrief model — look for related_searches and related_questions fields. Brand context building follows the same pattern as cluster keywords.",
      "completionNotes": "Completed by agent"
    },
    {
      "id": "S11-005",
      "title": "Create blog campaign CRUD API endpoints",
      "description": "As a developer, I need REST endpoints to create, list, view, update, and delete blog campaigns.",
      "acceptanceCriteria": [
        "Create backend/app/api/v1/blogs.py with APIRouter (prefix='/projects/{project_id}/blogs')",
        "POST / — Create campaign: validate cluster exists and has completed content, validate no existing campaign for that cluster (409), run BlogTopicDiscoveryService.discover_topics with timeout, return BlogCampaignResponse",
        "GET / — List campaigns: return BlogCampaignListItem[] with post counts and cluster name, ordered by created_at desc",
        "GET /{blog_id} — Get campaign with all posts: return BlogCampaignResponse with nested BlogPostResponse[]",
        "PATCH /{blog_id}/posts/{post_id} — Update post: edit keyword, url_slug, is_approved via BlogPostUpdate schema",
        "POST /{blog_id}/approve — Bulk approve all unapproved posts, update campaign status to 'writing' if all approved",
        "DELETE /{blog_id} — Delete campaign and all posts (cascade)",
        "Register router in backend/app/api/v1/__init__.py",
        "All endpoints validate project exists (404), use proper HTTP status codes, follow Depends(get_session) pattern"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Follow CRUD pattern from backend/app/api/v1/clusters.py. The creation endpoint is the heaviest — it triggers the 4-stage discovery pipeline inline (not as a background task, since it takes ~10-30s like cluster creation). Use the same timeout and error handling pattern as the cluster creation endpoint.",
      "completionNotes": "Completed by agent"
    },
    {
      "id": "S11-006",
      "title": "Create blog content prompt template",
      "description": "As a developer, I need a blog-specific prompt template for Claude content generation that outputs 3 fields instead of 4.",
      "acceptanceCriteria": [
        "Add build_blog_content_prompt(blog_post, keyword, brand_config, content_brief) function to backend/app/services/content_writing.py",
        "Reuse _build_system_prompt() for the system prompt (same writing rules, AI trope avoidance, formatting standards)",
        "User prompt specifies 3-field JSON output: { page_title, meta_description, content }",
        "page_title: SEO-optimized, includes primary keyword, under 60 chars",
        "meta_description: optimized for CTR, includes primary keyword, 150-160 chars",
        "content: full article HTML with Introduction (hook + thesis), Body H2 sections, FAQ section (from POP related_questions), Conclusion with CTA",
        "No top_description field (that's collection-page specific)",
        "Reuse _build_seo_targets_section() for LSI terms and heading targets from POP brief",
        "Inject brand voice from brand config ai_prompt_snippet",
        "Filter competitor names from LSI terms (reuse existing competitor filtering logic)"
      ],
      "priority": 2,
      "passes": true,
      "notes": "This modifies an existing file: backend/app/services/content_writing.py. The existing build_content_prompt() handles collection pages with 4 fields. The new build_blog_content_prompt() is a separate function that outputs 3 fields. The system prompt is shared via _build_system_prompt(). Reference the copywriting skill bible integration from Phase 5.",
      "completionNotes": "Completed by agent"
    },
    {
      "id": "S11-007",
      "title": "Create blog content generation pipeline orchestrator",
      "description": "As a developer, I need a pipeline that orchestrates brief→write→check for each approved blog post with concurrency control.",
      "acceptanceCriteria": [
        "Create backend/app/services/blog_content_generation.py with run_blog_content_pipeline(campaign_id, db, force_refresh=False, refresh_briefs=False) function",
        "Load approved BlogPost records (is_approved=True) for the campaign",
        "Per-post pipeline: (1) set content_status='generating', fetch POP brief with page_not_built_yet=True, store as pop_brief JSONB, (2) call Claude via build_blog_content_prompt, parse JSON response into title/meta_description/content, (3) run quality checks (reuse content_quality.py), store qa_results, (4) set content_status='complete'",
        "Uses asyncio.Semaphore for concurrency (CONTENT_GENERATION_CONCURRENCY env var, default 1)",
        "Error isolation: if one post fails, others continue; failed post gets content_status='failed'",
        "Skips posts already with content_status='complete' unless force_refresh=True",
        "Updates campaign status to 'review' when all posts complete"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Follow the exact pattern from backend/app/services/content_generation.py (run_content_pipeline). Key difference: content is stored directly on BlogPost (title, meta_description, content) not in a separate PageContent table. Reuse pop_content_brief.py for POP API calls and content_quality.py for QA checks.",
      "completionNotes": "Completed by agent"
    },
    {
      "id": "S11-008",
      "title": "Create blog content generation API endpoints",
      "description": "As a developer, I need API endpoints to trigger blog content generation, poll progress, and manage blog content.",
      "acceptanceCriteria": [
        "Add to backend/app/api/v1/blogs.py:",
        "POST /{blog_id}/generate-content — Returns 202 Accepted, starts background task, validates campaign status is 'writing' and has approved posts (400 if not), prevents duplicate runs (409 if already generating)",
        "GET /{blog_id}/content-status — Returns BlogContentGenerationStatus with per-post status breakdown",
        "GET /{blog_id}/posts/{post_id}/content — Returns full BlogPost content fields + qa_results + pop_brief summary",
        "PUT /{blog_id}/posts/{post_id}/content — Partial update of title/meta_description/content via BlogContentUpdateRequest, clears content_approved on change",
        "POST /{blog_id}/posts/{post_id}/approve-content — Set content_approved=True (with ?value=false to unapprove)",
        "POST /{blog_id}/posts/{post_id}/recheck — Re-run quality checks on current content, return updated qa_results",
        "POST /{blog_id}/bulk-approve-content — Approve all posts with content_status='complete' and qa passed"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Follow the trigger/poll pattern from backend/app/api/v1/content_generation.py. Use background_tasks.add_task() for the pipeline. Track active generations in a module-level set to prevent duplicates.",
      "completionNotes": "Completed by agent"
    },
    {
      "id": "S11-009",
      "title": "Add blog scope to internal link planning",
      "description": "As a developer, I need the link planning infrastructure to support blog posts siloed to their parent cluster.",
      "acceptanceCriteria": [
        "Add BLOG = 'blog' to LinkScope enum in backend/app/models/internal_link.py",
        "Add build_blog_graph(campaign_id, db) method to SiloLinkPlanner in backend/app/services/link_planning.py",
        "Blog graph: blog posts are leaf nodes, cluster pages are targets. Blogs link UP to cluster pages (2-4 links, parent page mandatory as first link) and sideways to sibling blogs (1-2 links). Total budget: 3-6 per blog post",
        "Create CrawledPage records with source='blog' for blog posts when link planning runs (bridges blog posts to existing InternalLink infrastructure which uses CrawledPage IDs)",
        "Blog links NEVER cross outside the cluster silo",
        "Add blog link planning API endpoints to blogs.py: POST /{blog_id}/plan-links (trigger, 202), GET /{blog_id}/link-status (poll), GET /{blog_id}/link-map (results)",
        "After link injection, update BlogPost.content with injected HTML"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Reuse existing SiloLinkPlanner, AnchorTextSelector, LinkInjector, and LinkValidator from backend/app/services/link_planning.py and link_injection.py. The blog-specific part is just the graph building (which pages can link to which). The CrawledPage bridging follows the same pattern as bulk_approve_cluster in clusters.py which creates CrawledPage records for cluster pages.",
      "completionNotes": "Completed by agent"
    },
    {
      "id": "S11-010",
      "title": "Create blog HTML export service",
      "description": "As a developer, I need an export service that generates clean HTML for blog posts (NOT Matrixify CSV).",
      "acceptanceCriteria": [
        "Create backend/app/services/blog_export.py with BlogExportService class",
        "generate_clean_html(blog_post): strip editor artifacts (highlight spans, data attributes), preserve internal links, ensure proper heading hierarchy (H2/H3), return semantic HTML string",
        "generate_export_package(campaign_id, db, post_ids=None): query approved posts (content_approved=True, content_status='complete'), generate clean HTML + metadata for each, return list of BlogExportItem",
        "Add export API endpoints to blogs.py: GET /{blog_id}/export (all approved posts as JSON array of BlogExportItem), GET /{blog_id}/posts/{post_id}/export (single post), GET /{blog_id}/posts/{post_id}/download (HTML file with Content-Disposition header)",
        "HTML cleaning reuses the strip pattern from the existing Lexical editor export (removing highlight nodes)"
      ],
      "priority": 2,
      "passes": false,
      "notes": "Blog export is HTML for pasting into Shopify's blog editor. NOT Matrixify CSV (that's collection pages only). The highlight stripping logic exists in the frontend Lexical editor (HighlightPlugin.tsx lines 68-80) — replicate server-side with BeautifulSoup for the backend export."
    },
    {
      "id": "S11-011",
      "title": "Write backend tests for blog services and API",
      "description": "As a developer, I need comprehensive tests for blog topic discovery, content generation, export, and API endpoints.",
      "acceptanceCriteria": [
        "Tests for blog topic discovery: mock Claude + DataForSEO, test 4-stage pipeline, test seed extraction from POP briefs, test deduplication, test error handling",
        "Tests for blog content generation pipeline: mock POP + Claude, test per-post pipeline phases, test error isolation, test concurrency control, test skip-if-complete logic",
        "Tests for blog export: test HTML cleaning (highlight strip, link preservation), test export package generation",
        "Tests for blog API endpoints: test campaign CRUD (create/list/get/update/delete), test content generation trigger/poll, test content edit/approve/recheck, test export endpoints, test validation (no duplicate campaigns per cluster, must have approved posts for generation)",
        "All tests pass: cd backend && python -m pytest tests/ -x",
        "Minimum 40 test cases across services and API"
      ],
      "priority": 3,
      "passes": false,
      "notes": "Follow existing test patterns in backend/tests/services/ and backend/tests/api/. Use conftest.py fixtures. Mock external APIs (Claude, DataForSEO, POP) — never make real API calls in tests."
    },
    {
      "id": "S11-012",
      "title": "Add blog types and API functions to frontend API client",
      "description": "As a developer, I need TypeScript types and API functions for all blog endpoints so the frontend can interact with them.",
      "acceptanceCriteria": [
        "Add to frontend/src/lib/api.ts: BlogCampaign, BlogPost, BlogCampaignCreate, BlogCampaignListItem, BlogPostUpdate, BlogContentUpdate, BlogContentGenerationStatus, BlogExportItem TypeScript interfaces",
        "Add API functions: createBlogCampaign(projectId, data), getBlogCampaigns(projectId), getBlogCampaign(projectId, blogId), updateBlogPost(projectId, blogId, postId, data), bulkApproveBlogPosts(projectId, blogId), deleteBlogCampaign(projectId, blogId)",
        "Add content API functions: triggerBlogContentGeneration(projectId, blogId), getBlogContentStatus(projectId, blogId), getBlogPostContent(projectId, blogId, postId), updateBlogPostContent(projectId, blogId, postId, data), approveBlogPostContent(projectId, blogId, postId, value?), recheckBlogPostContent(projectId, blogId, postId), bulkApproveBlogContent(projectId, blogId)",
        "Add link API functions: triggerBlogLinkPlanning(projectId, blogId), getBlogLinkStatus(projectId, blogId), getBlogLinkMap(projectId, blogId)",
        "Add export API functions: getBlogExport(projectId, blogId), getBlogPostExport(projectId, blogId, postId), downloadBlogPostHtml(projectId, blogId, postId)",
        "Follow exact patterns from existing cluster/content API functions in the same file"
      ],
      "priority": 2,
      "passes": false,
      "notes": "All blog endpoints are under /projects/{projectId}/blogs/{blogId}/... prefix. Follow the existing apiClient.get/post/put/patch/delete patterns. The download function should handle blob response like the existing exportProject function."
    },
    {
      "id": "S11-013",
      "title": "Create useBlogs TanStack Query hooks",
      "description": "As a developer, I need React Query hooks for blog campaigns, content generation, and export so the frontend components can fetch and mutate data.",
      "acceptanceCriteria": [
        "Create frontend/src/hooks/useBlogs.ts",
        "Query key factory: blogKeys with list, detail, contentStatus, postContent, linkStatus, linkMap, export keys",
        "Campaign hooks: useBlogCampaigns(projectId), useBlogCampaign(projectId, blogId), useCreateBlogCampaign(), useUpdateBlogPost(), useBulkApproveBlogPosts(), useDeleteBlogCampaign()",
        "Content hooks: useTriggerBlogContentGeneration(), useBlogContentStatus(projectId, blogId) with 3s polling while generating, useBlogPostContent(projectId, blogId, postId), useUpdateBlogPostContent(), useApproveBlogPostContent(), useRecheckBlogPostContent(), useBulkApproveBlogContent()",
        "Link hooks: useTriggerBlogLinkPlanning(), useBlogLinkStatus(projectId, blogId) with polling, useBlogLinkMap(projectId, blogId)",
        "All mutations invalidate relevant queries on success",
        "Follow exact patterns from frontend/src/hooks/useClusters.ts and frontend/src/hooks/useContentGeneration.ts"
      ],
      "priority": 2,
      "passes": false,
      "notes": "The polling pattern for content status: refetchInterval: (query) => query.state.data?.overall_status === 'generating' ? 3000 : false. Same pattern for link planning status. Query key hierarchy enables cache invalidation at list vs detail level."
    },
    {
      "id": "S11-014",
      "title": "Add Blogs section to project detail page",
      "description": "As a user, I need to see my blog campaigns on the project detail page alongside onboarding and clusters.",
      "acceptanceCriteria": [
        "Modify frontend/src/app/projects/[id]/page.tsx to add a third section below 'New Content'",
        "Section header: pencil icon + 'Blogs' title + 'Supporting Content' chip badge (matching onboarding/cluster header pattern)",
        "When campaigns exist: show grid of campaign cards (1-3 columns), each card shows: campaign name, cluster name (small text), post count ('X of Y posts done'), status badge (Planning/Writing/Review/Complete), link status badge",
        "When no campaigns: empty state with 'No blog campaigns yet' + description + '+ New Campaign' button",
        "'+ New Campaign' button in header (when campaigns exist) links to /projects/[id]/blogs/new",
        "Each campaign card links to /projects/[id]/blogs/[blogId]",
        "Card styling matches ClusterCard: bg-white rounded-sm border border-sand-500 p-4 shadow-sm hover:shadow-md transition-shadow",
        "Fetch campaigns with useBlogCampaigns hook"
      ],
      "priority": 2,
      "passes": false,
      "notes": "Follow the exact layout pattern of the existing 'New Content' section (lines 765-807 of the project detail page). The BlogCampaignCard component should mirror ClusterCard (lines 367-398). Status badge colors: planning=cream, writing=lagoon, review=coral, complete=palm."
    },
    {
      "id": "S11-015",
      "title": "Create blog campaign creation page",
      "description": "As a user, I need a page to create a blog campaign by selecting a cluster and triggering topic discovery.",
      "acceptanceCriteria": [
        "Create frontend/src/app/projects/[id]/blogs/new/page.tsx",
        "Form: dropdown to select parent cluster (only clusters with completed content are eligible — filter by status), optional campaign name input",
        "Ineligible clusters (no completed content) shown grayed out with reason",
        "Clusters that already have a campaign are excluded from dropdown",
        "On submit: call createBlogCampaign mutation, show 4-step progress animation during discovery (Extracting seeds → Expanding topics → Checking volume → Filtering results)",
        "On success: redirect to campaign detail page (keywords step)",
        "On error: show error message with retry option",
        "Cancel button returns to project detail page",
        "Follow creation page pattern from frontend/src/app/projects/[id]/clusters/new/page.tsx",
        "Tropical oasis styling: rounded-sm, palm/sand/cream colors, warm-gray text"
      ],
      "priority": 2,
      "passes": false,
      "notes": "The cluster dropdown needs data from useClusters hook to show available clusters. The progress animation follows the ProgressIndicator pattern from clusters/new/page.tsx (lines 32-70). The discovery takes ~10-30s, similar to cluster creation."
    },
    {
      "id": "S11-016",
      "title": "Create blog keywords step page",
      "description": "As a user, I need to view, edit, and approve discovered blog topics before content generation.",
      "acceptanceCriteria": [
        "Create frontend/src/app/projects/[id]/blogs/[blogId]/page.tsx",
        "5-step indicator at top: Keywords (active) → Content → Links → Review → Export",
        "Table showing all blog posts with columns: Approve checkbox, Topic Keyword (inline editable), Source Page (which cluster page seeded it), Volume, URL Slug (inline editable)",
        "Inline editing: click keyword or slug cell to enter edit mode, blur to save via useUpdateBlogPost mutation",
        "Approve checkbox per row toggles is_approved via useUpdateBlogPost",
        "Bulk 'Approve All' button approves all unapproved posts",
        "Bottom actions: 'Delete Campaign' (left, danger), 'Generate Content →' (right, primary — disabled until ≥1 approved)",
        "'Generate Content' navigates to content step and triggers generation",
        "Follow keyword approval pattern from frontend/src/app/projects/[id]/clusters/[clusterId]/page.tsx",
        "Tropical oasis styling consistent with cluster keywords page"
      ],
      "priority": 2,
      "passes": false,
      "notes": "Follow the ClusterPageRow pattern (lines 293-471 of cluster detail page). Key difference from clusters: no parent/child roles, no CPC/competition/score columns (blogs are simpler). Add Source Page column showing which cluster page's POP report seeded the topic. The step indicator follows the StepIndicator pattern (lines 79-122)."
    },
    {
      "id": "S11-017",
      "title": "Create blog content generation and review page",
      "description": "As a user, I need to trigger blog content generation, watch progress, and review generated content in a tabbed table.",
      "acceptanceCriteria": [
        "Create frontend/src/app/projects/[id]/blogs/[blogId]/content/page.tsx",
        "Step indicator shows Content (active, step 2)",
        "Generation state: 'Generate Content' button, progress bar with per-post pipeline indicator (Brief → Write → Check → Done), per-post status rows with View/Inspect actions",
        "Polls every 3s while generating via useBlogContentStatus hook",
        "Review state (after generation): two tabs 'Needs Review' / 'Approved' with table showing topic keyword, word count, QA status (pass/fail), content approval toggle, Edit link",
        "Edit link navigates to /blogs/[blogId]/content/[postId] (content editor)",
        "'Approve All Ready' button approves all QA-passed posts",
        "After all content generated, auto-trigger link planning (same pattern as cluster content page)",
        "Navigation: '← Back' to keywords, 'Continue →' to links/export",
        "Follow content generation page pattern from frontend/src/app/projects/[id]/clusters/[clusterId]/content/page.tsx"
      ],
      "priority": 2,
      "passes": false,
      "notes": "This page is a near-copy of the cluster content page. The main structural difference: it queries BlogPost records instead of CrawledPage+PageContent. The pipeline indicator, polling, tabs, and approval flow are identical patterns. Reference the PipelineIndicator (lines 168-230), PageRow (lines 267-353), and ReviewTable (lines 374-537) from the cluster content page."
    },
    {
      "id": "S11-018",
      "title": "Create blog content editor page (3 fields)",
      "description": "As a user, I need a rich text editor for blog posts with 3 fields (title, meta description, content), QA sidebar, and auto-save.",
      "acceptanceCriteria": [
        "Create frontend/src/app/projects/[id]/blogs/[blogId]/content/[postId]/page.tsx",
        "Two-column layout: editor (65%) + sidebar (35%)",
        "Editor has 3 fields (NOT 4 — no top_description): Page Title (input, 70 char counter), Meta Description (textarea, 160 char counter), Content (ContentEditorWithSource Lexical editor with HTML source toggle)",
        "Content field shows word count + heading count footer: 'X words · Y H2 · Z H3'",
        "Highlight toggle controls for keyword, LSI, trope highlighting (reuse HighlightPlugin)",
        "Sidebar: QualityStatusCard (pass/fail checks), ContentStatsCard (word count, headings, keyword density), LsiTermsCard (LSI term usage), HeadingOutlineCard (H2/H3 structure)",
        "Auto-save on blur with dirty field tracking (same pattern as existing editor)",
        "Bottom action bar: auto-save status, 'Re-run Checks' button, 'Save Draft' button, 'Approve' button",
        "Approve button navigates back to content list",
        "Follow editor pattern from frontend/src/app/projects/[id]/clusters/[clusterId]/content/[pageId]/page.tsx (adapt from 4 fields to 3)"
      ],
      "priority": 2,
      "passes": false,
      "notes": "This is the existing content editor with one field removed (top_description). The ContentEditorWithSource component, HighlightPlugin, ToolbarPlugin, and all sidebar components are reused from existing code in frontend/src/components/content-editor/. The auto-save logic (lines 700-761 of existing editor) needs minor adaptation for 3 fields instead of 4. QA results come from BlogPost.qa_results instead of PageContent.qa_results."
    },
    {
      "id": "S11-019",
      "title": "Create blog link planning and link map pages",
      "description": "As a user, I need to trigger link planning for blog posts and view the resulting link map.",
      "acceptanceCriteria": [
        "Create frontend/src/app/projects/[id]/blogs/[blogId]/links/page.tsx — link planning trigger page",
        "Prerequisites checklist: all keywords approved, all content generated",
        "'Plan & Inject Links' button (disabled if prerequisites not met)",
        "Progress indicator during planning (4 steps: Building graph → Selecting targets → Injecting links → Validating)",
        "Link rules card explaining blog-specific rules (2-4 links to cluster pages, 1-2 to sibling blogs, siloed)",
        "Create frontend/src/app/projects/[id]/blogs/[blogId]/links/map/page.tsx — link map visualization",
        "Two sections: Cluster Pages (link targets, showing inbound counts) and Blog Posts (showing outbound links with anchor text and target)",
        "Stats header: total links, total posts, avg links/post",
        "'Re-plan Links' button for re-planning",
        "Follow link planning pattern from cluster links page at frontend/src/app/projects/[id]/clusters/[clusterId]/links/page.tsx and links/map/page.tsx"
      ],
      "priority": 2,
      "passes": false,
      "notes": "These pages are structural copies of the cluster link pages. The blog link map has a different visual structure: cluster pages shown as 'targets' at the top, blog posts shown below with their outbound links. This makes the silo relationship clear — blogs link UP to cluster pages and sideways to sibling blogs."
    },
    {
      "id": "S11-020",
      "title": "Create blog HTML export page",
      "description": "As a user, I need to export blog posts as clean HTML to paste into Shopify's blog editor.",
      "acceptanceCriteria": [
        "Create frontend/src/app/projects/[id]/blogs/[blogId]/export/page.tsx",
        "Step indicator shows Export (active, step 5)",
        "Header: 'Export Blog Posts' + subtitle 'Copy HTML to paste into Shopify, or download as files'",
        "Show count: 'Ready to export: X of Y posts approved'",
        "List of approved blog posts, each as a card showing: keyword, URL slug, word count, title, meta description (truncated)",
        "Per-post actions: 'Copy HTML' button (copies clean HTML body to clipboard via navigator.clipboard.writeText), 'Download .html' button (triggers file download)",
        "'Copy HTML' shows 'Copied!' toast on success (2s timeout), button icon changes to checkmark briefly",
        "Bottom bar: '← Back' button, 'Copy All HTML' button (copies all posts concatenated with <!-- POST: keyword --> separators)",
        "Unapproved posts shown grayed out at bottom",
        "This is NOT Matrixify CSV — it's HTML for Shopify blog editor"
      ],
      "priority": 2,
      "passes": false,
      "notes": "This is the only genuinely NEW UI in Phase 11. The clipboard pattern exists in PromptInspector.tsx (CopyButton component, lines 127-155) — reuse that pattern. For file download, create a Blob with type 'text/html' and trigger download via hidden anchor element (same pattern as the existing CSV export but with HTML content type). The export cards should show title and meta as copyable text fields above the action buttons."
    },
    {
      "id": "S11-021",
      "title": "Write frontend component tests",
      "description": "As a developer, I need tests for blog UI components to ensure they render and behave correctly.",
      "acceptanceCriteria": [
        "Tests for useBlogs hooks: query/mutation behavior, polling, cache invalidation",
        "Tests for project detail Blogs section: renders campaign cards, empty state, status badges",
        "Tests for campaign creation page: form validation, cluster dropdown filtering, progress animation",
        "Tests for keywords step: table rendering, inline editing, approve/bulk-approve",
        "Tests for content generation page: progress display, tab switching, approve flow",
        "Tests for content editor page: 3-field layout, auto-save, sidebar rendering",
        "Tests for export page: clipboard copy, download trigger, card rendering",
        "All tests pass: cd frontend && npm test",
        "Minimum 40 frontend test cases"
      ],
      "priority": 3,
      "passes": false,
      "notes": "Follow existing test patterns in frontend/src/__tests__/. Mock API calls and TanStack Query. Use renderHook for hook tests, render for component tests. The clipboard API (navigator.clipboard.writeText) needs to be mocked in tests."
    },
    {
      "id": "S11-098",
      "title": "Update V2_REBUILD_PLAN.md",
      "description": "As a developer, I need to update the plan status so that progress is tracked.",
      "acceptanceCriteria": [
        "Mark all Phase 11 checkboxes as [x] complete in V2_REBUILD_PLAN.md",
        "Update Current Status table: Phase=11 Blog Planning & Writing (COMPLETE), Last Session=today's date, Next Action=Phase 12: Authentication",
        "Add new row to Session Log table with date, completed items summary, next up"
      ],
      "priority": 3,
      "passes": false,
      "notes": "This task maintains our planning discipline."
    },
    {
      "id": "S11-099",
      "title": "Verify Phase 11 completion",
      "description": "As a developer, I need to verify all Phase 11 criteria are met before moving on.",
      "acceptanceCriteria": [
        "All backend tests pass: cd backend && python -m pytest tests/ -x",
        "All frontend tests pass: cd frontend && npm test",
        "Manual verification: full blog flow works end-to-end (create campaign from cluster → approve topics → generate content → edit in Lexical → plan links → view link map → copy HTML to clipboard)",
        "Blog export produces clean HTML (no editor artifacts, links preserved)",
        "Blog linking is siloed (only cluster pages + sibling blogs, never outside silo)",
        "Project detail page shows blog campaigns section",
        "Git commit created with message: feat(phase-11): Add blog planning & writing",
        "No uncommitted changes remain"
      ],
      "priority": 3,
      "passes": false,
      "notes": "Do not proceed to Phase 12 until this passes. The critical path: campaign creation, content generation, and HTML export."
    }
  ],
  "metadata": {
    "updatedAt": "2026-02-14T21:50:11.605Z"
  }
}